grammar org.xtext.ecerule.Ece with org.eclipse.xtext.common.Terminals

generate ece "http://www.xtext.org/ecerule/Ece"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

DroolsModel:
	statements += Statement*
;


Statement:
	'on' event=Event 'set' fluent+=Fluent (',' fluent+=Fluent)*  ('expect' exp+=ExpFluent (',' exp+=ExpFluent)*)? ';' 	
;

Event:
	eventName=ID		
;

Fluent:
	fluentName=ID	
	('to' valuePart = ToRule)
	('in' timePart = InRule)? 
	('if' condPart = ConditionRule)?
;





//TO RULE ******************************************************************
ToRule:
	expression = StringExpr 
	|=>expression = BoolExpr 
	|(expression = switchExpr) //switch BoolExpr
	|=>(expression = FloatExpr) 
	|(expression = MutationExpr)//mutation FloatExpr
;


StringExpr:
	Str 
	|FluentWhoseValue
;

BoolExpr:
	value='true'|value='false'| Or 
;

Or:
	And ({Or.left=current} "OR" right=And)* 
;

And:
	Equality ({And.left=current} "AND" right=Equality)* 
	|=>Equality ({And.left=current} "AND" right=Comparison)* 
	|=>Comparison ({And.left=current} "AND" right=Comparison)* 
	|=>Comparison ({And.left=current} "AND" right=Equality)* 
//	|=>Equality ({And.left=current} "AND" right=BoolExpr)* 
//	|=>Comparison ({And.left=current} "AND" right=BoolExpr)*
;


Equality:
	FloatExpr (
		{Equality.left=current} op=("=="|"!=")
		right=FloatExpr
	) 
	|=>StringExpr (
		{Equality.left=current} op=("=="|"!=")
		right=StringExpr
	)* 
;


Comparison:
	PlusOrMinus (
		{Comparison.left=current} op=(">="|"<="|">"|"<")
		right=PlusOrMinus
	)* 
;


switchExpr:
	value="switch"
;

MutationExpr:
	value=('+'|'-'|'*'|'/'|'^') FLOAT
;


FloatExpr:
	=>valueDirect=INT
	|valueCalculated=PlusOrMinus 
	|=>valueOfFluent=FluentWhoseValue
;

terminal FLOAT returns ecore::EFloat: ('0'..'9')*'.'('0'..'9')+;


PlusOrMinus:
	MulOrDiv (
	({Plus.left=current} '+' | {Minus.left=current} '-')
	right=MulOrDiv
	)* 
;

MulOrDiv:
	Primary (
		{MulOrDiv.left=current} op=('*'|'/'|'%'|'^')
		right=Primary
	)*
;

Primary:
	valueDirect=INT 
	|valueOfFluent=FluentWhoseValue
;



FluentWhoseValue: //in una fase successiva verr√† tradotto in valore numerico/bool/stringa?
	fluentWhoseValueName=ID
;

Str:
	value=STRING
;


//IN RULE ******************************************************************
InRule:	
	time=INT|	
	currentTime='now'
;


//CONDITION RULE ***********************************************************
ConditionRule:
	condition = BoolExpr
;







ExpFluent:
	fluentName=ID	
	('to' valuePart = ToRule)
	('in' timePart = InRule)? 
;





