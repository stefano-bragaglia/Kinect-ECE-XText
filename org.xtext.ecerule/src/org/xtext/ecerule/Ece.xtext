grammar org.xtext.ecerule.Ece with org.eclipse.xtext.common.Terminals

generate ece "http://www.xtext.org/ecerule/Ece"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

EceModel:
	statements+=Statement*;

Statement:
	'on' event=Event contextsList=ContextsList ';';

Event:
	eventName=ID 
	('(' params+=EventFeature (',' params+=EventFeature)* ')')?;

EventFeature:
	name=ID;

ContextsList:
	ecContextsList=EcContextsList (',' expContextsList=ExpContextsList)?;


EcContextsList:
	ecContexts+=EcContext (',' ecContexts+=EcContext)*;
	
ExpContextsList:
	expContexts+=ExpContext (',' expContexts+=ExpContext)*
;




// EC CONTEXT ******************************************************************
EcContext:
	'set' fluent+=Fluent (',' fluent+=Fluent)* 
;






// EXP CONTEXT *****************************************************************
ExpContext:
	'expect' finalCondition=ConditionRule (allenOp=AllenOp time=Time)? ('if' initialCondition=ConditionRule)?
;

Time:
	t=INT
;

AllenOp:
	{AllenOperator} value=('before'|'meets'|'overlaps'|'starts'|'finishes'|'during') 
;
	
	

	
	
	
	
	
	
	

Fluent:
	fluentName=ID	
	('to' valuePart = ToRule)
	('in' timePart = InRule)? 
	('if' condPart = ConditionRule)?
;

ConditionRule:
	({Expression} condition = Expression)
;

ToRule:
	({Expression} expression = PlusOrMinus)
;

InRule:	
	time=INT	
//	|currentTime='now'
;



// LEFT_ASSOCIATIVITY
Expression: Or;

Or returns Expression:
	And ({Or.left=current} "OR" right=And)* 
;

And returns Expression:
	Equality ({And.left=current} "AND" right=Equality)* 
;

Equality returns Expression:
	Comparison (
		{Equality.left=current} op=("=="|"!=")
		right=Comparison
	)* 
;

Comparison returns Expression:
	PlusOrMinus (
		{Comparison.left=current} op=(">="|"<="|">"|"<")
		right=PlusOrMinus
	)* 
;

PlusOrMinus returns Expression:
	MulOrDiv (
	({Plus.left=current} '+' | {Minus.left=current} '-')
	right=MulOrDiv
	)* 
;

MulOrDiv returns Expression:
	Primary (
		{MulOrDiv.left=current} op=('*'|'/'|'%'|'^')
		right=Primary
	)*
;

Primary returns Expression:
	'(' Expression ')' |
	{Not} "!" expression=Primary |
	Atomic
;

Atomic returns Expression:
	{FloatConstant} value=FLOAT |
	{IntConstant} value=INT |
//	{StringConstant} value=STRING | 
	{BoolConstant} value=('true'|'false') |
	{FeatureRef} param = [EventFeature] |
	{FluentRef} '['value=ID']'
;




terminal FLOAT returns ecore::EFloat: ('0'..'9')*'.'('0'..'9')+;